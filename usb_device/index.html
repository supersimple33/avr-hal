<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Experimental device-side USB stack for embedded devices."><title>usb_device - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-c5d6553a23f1e5a6.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="usb_device" data-themes="" data-resource-suffix="" data-rustdoc-version="1.82.0-nightly (92c6c0380 2024-07-21)" data-channel="nightly" data-search-js="search-d234aafac6c221dd.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-d2fab2bf619172d3.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../usb_device/index.html">usb_device</a><span class="version">0.3.2</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#enums">Enums</a></li><li><a href="#types">Type Aliases</a></li></ul></section></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">usb_device</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/usb_device/lib.rs.html#1-276">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Experimental device-side USB stack for embedded devices.</p>
<h3 id="implementing-a-usb-device"><a class="doc-anchor" href="#implementing-a-usb-device">§</a>Implementing a USB device</h3>
<p>A USB device consists of a <a href="device/struct.UsbDevice.html" title="struct usb_device::device::UsbDevice"><code>UsbDevice</code></a> instance, one or more
<a href="class/trait.UsbClass.html" title="trait usb_device::class::UsbClass"><code>UsbClass</code></a>es, and a platform-specific <a href="bus/trait.UsbBus.html" title="trait usb_device::bus::UsbBus"><code>UsbBus</code></a>
implementation which together form a USB composite device.</p>
<p>In the future USB device implementors will be able to use pre-existing peripheral driver crates
and USB class implementation crates. The necessary types for the basic USB composite device
implementation are available with:</p>
<p><code>use usb_device::prelude::*</code>.</p>
<p>See the <a href="device/index.html" title="mod usb_device::device"><code>device</code></a> module for a more complete example.</p>
<h3 id="usb-classes"><a class="doc-anchor" href="#usb-classes">§</a>USB classes</h3>
<p>For information on how to implement new USB classes, see the <a href="class/index.html" title="mod usb_device::class"><code>class</code></a> module and the
<a href="test_class/struct.TestClass.html" title="struct usb_device::test_class::TestClass"><code>TestClass</code></a> source code for an example of a custom USB device class
implementation. The necessary types for creating new classes are available with:</p>
<p><code>use usb_device::class_prelude::*</code>.</p>
<h3 id="usb-peripheral-drivers"><a class="doc-anchor" href="#usb-peripheral-drivers">§</a>USB peripheral drivers</h3>
<p>New peripheral driver crates can be created by implementing the <a href="bus/trait.UsbBus.html" title="trait usb_device::bus::UsbBus"><code>UsbBus</code></a> trait.</p>
<h2 id="note-about-terminology"><a class="doc-anchor" href="#note-about-terminology">§</a>Note about terminology</h2>
<p>This crate uses standard host-centric USB terminology for transfer directions. Therefore an OUT
transfer refers to a host-to-device transfer, and an IN transfer refers to a device-to-host
transfer. This is mainly a concern for implementing new USB peripheral drivers and USB classes,
and people doing that should be familiar with the USB standard.</p>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.LangID"><code>pub use descriptor::lang_id::<a class="struct" href="descriptor/lang_id/struct.LangID.html" title="struct usb_device::descriptor::lang_id::LangID">LangID</a>;</code></div></li></ul><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="bus/index.html" title="mod usb_device::bus">bus</a></div><div class="desc docblock-short">For implementing peripheral drivers.</div></li><li><div class="item-name"><a class="mod" href="class/index.html" title="mod usb_device::class">class</a></div><div class="desc docblock-short">For implementing standard as well as vendor-specific USB classes.</div></li><li><div class="item-name"><a class="mod" href="class_prelude/index.html" title="mod usb_device::class_prelude">class_prelude</a></div><div class="desc docblock-short">Prelude for class implementors.</div></li><li><div class="item-name"><a class="mod" href="control/index.html" title="mod usb_device::control">control</a></div><div class="desc docblock-short">USB control transfers and the SETUP packet.</div></li><li><div class="item-name"><a class="mod" href="descriptor/index.html" title="mod usb_device::descriptor">descriptor</a></div><div class="desc docblock-short">Creating USB descriptors</div></li><li><div class="item-name"><a class="mod" href="device/index.html" title="mod usb_device::device">device</a></div><div class="desc docblock-short">USB composite device.</div></li><li><div class="item-name"><a class="mod" href="endpoint/index.html" title="mod usb_device::endpoint">endpoint</a></div><div class="desc docblock-short">USB endpoints.</div></li><li><div class="item-name"><a class="mod" href="prelude/index.html" title="mod usb_device::prelude">prelude</a></div><div class="desc docblock-short">Prelude for device implementors.</div></li><li><div class="item-name"><a class="mod" href="test_class/index.html" title="mod usb_device::test_class">test_class</a></div><div class="desc docblock-short">Test USB class for testing USB driver implementations. Peripheral driver implementations should
include an example called “test_class” that creates a device with this class to enable the
driver to be tested with the test_class_host example in this crate.</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.UsbDirection.html" title="enum usb_device::UsbDirection">UsbDirection</a></div><div class="desc docblock-short">Direction of USB traffic. Note that in the USB standard the direction is always indicated from
the perspective of the host, which is backward for devices, but the standard directions are used
for consistency.</div></li><li><div class="item-name"><a class="enum" href="enum.UsbError.html" title="enum usb_device::UsbError">UsbError</a></div><div class="desc docblock-short">A USB stack error.</div></li></ul><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.Result.html" title="type usb_device::Result">Result</a></div><div class="desc docblock-short">Result for USB operations.</div></li></ul></section></div></main></body></html>